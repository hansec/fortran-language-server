{
  "ABORT": {
    "doc": "ABORT causes immediate termination of the program.",
    "type": 2
  },
  "ABS": {
    "args": "A",
    "doc": "ABS(A) computes the absolute value of A.",
    "type": 3
  },
  "ACCESS": {
    "args": "NAME,MODE",
    "doc": "ACCESS(NAME,MODE) checks whether the file NAME exists, is readable, writable or executable.",
    "type": 3
  },
  "ACHAR": {
    "args": "I,KIND=kind",
    "doc": "ACHAR(I,KIND=kind) returns the character located at position I in the ASCII collating sequence.",
    "type": 3
  },
  "ACOS": {
    "args": "X",
    "doc": "ACOS(X) computes the arccosine of X (inverse of COS(X)).",
    "type": 3
  },
  "ACOSH": {
    "args": "X",
    "doc": "ACOSH(X) computes the inverse hyperbolic cosine of X.",
    "type": 3
  },
  "ADJUSTL": {
    "args": "STRING",
    "doc": "ADJUSTL(STRING) will left adjust a string by removing leading spaces.",
    "type": 3
  },
  "ADJUSTR": {
    "args": "STRING",
    "doc": "ADJUSTR(STRING) will right adjust a string by removing trailing spaces.",
    "type": 3
  },
  "AIMAG": {
    "args": "Z",
    "doc": "AIMAG(Z) yields the imaginary part of complex argument Z.",
    "type": 3
  },
  "AINT": {
    "args": "A,KIND=kind",
    "doc": "AINT(A,KIND=kind) truncates its argument to a whole number.",
    "type": 3
  },
  "ALL": {
    "args": "MASK,DIM=dim",
    "doc": "ALL(MASK,DIM=dim) determines if all the values are true in MASK in the array along dimension DIM.",
    "type": 3
  },
  "ALLOCATED": {
    "args": "A",
    "doc": "ALLOCATED(A) check the allocation status of A.",
    "type": 3
  },
  "ANINT": {
    "args": "A,KIND=kind",
    "doc": "ANINT(A,KIND=kind) rounds its argument to the nearest whole number.",
    "type": 3
  },
  "ANY": {
    "args": "MASK,DIM=dim",
    "doc": "ANY(MASK,DIM=dim) determines if any of the values are true in MASK in the array along dimension DIM.",
    "type": 3
  },
  "ASIN": {
    "args": "X",
    "doc": "ASIN(X) computes the arcsine of X (inverse of SIN(X)).",
    "type": 3
  },
  "ASINH": {
    "args": "X",
    "doc": "ASINH(X) computes the inverse hyperbolic sine of X.",
    "type": 3
  },
  "ASSOCIATED": {
    "args": "POINTER,TARGET=target",
    "doc": "ASSOCIATED(POINTER,TARGET=target) determines the status of the pointer POINTER or if POINTER is associated with the target TARGET.",
    "type": 3
  },
  "ATAN": {
    "args": "X",
    "doc": "ATAN(X) computes the arctangent of X (inverse of TAN(X)).",
    "type": 3
  },
  "ATAN2": {
    "args": "Y,X",
    "doc": "ATAN2(Y,X) computes the principal value of the argument function of the complex number X + i Y.",
    "type": 3
  },
  "ATANH": {
    "args": "X",
    "doc": "ATANH(X) computes the inverse hyperbolic tangent of X.",
    "type": 3
  },
  "BESSEL_J0": {
    "args": "X",
    "doc": "BESSEL_J0(X) computes the Bessel function of the first kind of order 0 of X.",
    "type": 3
  },
  "BESSEL_J1": {
    "args": "X",
    "doc": "BESSEL_J1(X) computes the Bessel function of the first kind of order 1 of X.",
    "type": 3
  },
  "BESSEL_JN": {
    "args": "N,X",
    "doc": "BESSEL_JN(N,X) computes the Bessel function of the first kind of order N of X.",
    "type": 3
  },
  "BESSEL_Y0": {
    "args": "X",
    "doc": "BESSEL_Y0(X) computes the Bessel function of the second kind of order 0 of X.",
    "type": 3
  },
  "BESSEL_Y1": {
    "args": "X",
    "doc": "BESSEL_Y1(X) computes the Bessel function of the second kind of order 1 of X.",
    "type": 3
  },
  "BESSEL_YN": {
    "args": "N,X",
    "doc": "BESSEL_YN(N,X) computes the Bessel function of the second kind of order N of X.",
    "type": 3
  },
  "BGE": {
    "args": "I,J",
    "doc": "BGE(I,J) determines whether an integral is a bitwise greater than or equal to another.",
    "type": 3
  },
  "BGT": {
    "args": "I,J",
    "doc": "BGT(I,J) determines whether an integral is a bitwise greater than another.",
    "type": 3
  },
  "BIT_SIZE": {
    "args": "I",
    "doc": "BIT_SIZE(I) returns the number of bits represented by the type of I",
    "type": 3
  },
  "BLE": {
    "args": "I,J",
    "doc": "BLE(I,J) determines whether an integral is a bitwise less than or equal to another.",
    "type": 3
  },
  "BLT": {
    "args": "I,J",
    "doc": "BLT(I,J) determines whether an integral is a bitwise less than another.",
    "type": 3
  },
  "BTEST": {
    "args": "I,J",
    "doc": "BTEST(I,POS) returns logical .TRUE. if the bit at POS in I is set.",
    "type": 3
  },
  "CEILING": {
    "args": "A,KIND=kind",
    "doc": "CEILING(A,KIND=kind) returns the least integer greater than or equal to A.",
    "type": 3
  },
  "CHAR": {
    "args": "I,KIND=kind",
    "doc": "CHAR(I,KIND=kind) returns the character represented by the integer I.",
    "type": 3
  },
  "CMPLX": {
    "args": "X,Y=y,KIND=kind",
    "doc": "CMPLX(X,Y=y,KIND=kind) returns a complex number where X is converted to the real component.",
    "type": 3
  },
  "COMMAND_ARGUMENT_COUNT": {
    "args": "X",
    "doc": "COMMAND_ARGUMENT_COUNT() returns the number of arguments passed on the command line when the containing program was invoked.",
    "type": 3
  },
  "CONJG": {
    "args": "Z",
    "doc": "CONJG(Z) returns the conjugate of Z.",
    "type": 3
  },
  "COS": {
    "args": "X",
    "doc": "COS(X) computes the cosine of X.",
    "type": 3
  },
  "COSH": {
    "args": "X",
    "doc": "COSH(X) computes the hyperbolic cosine of X.",
    "type": 3
  },
  "COTAN": {
    "args": "X",
    "doc": "COTAN(X) computes the cotangent of X.",
    "type": 3
  },
  "COUNT": {
    "args": "MASK,DIM=dim,KIND=kind",
    "doc": "COUNT(MASK,DIM=dim,KIND=kind) Count the number of true elements of MASK along dimension DIM.",
    "type": 3
  },
  "CPU_TIME": {
    "args": "TIME",
    "doc": "CPU_TIME(TIME) returns a REAL value representing the elapsed CPU time in seconds.",
    "type": 2
  },
  "CSHIFT": {
    "args": "ARRAY,SHIFT,DIM=dim",
    "doc": "CSHIFT(ARRAY,SHIFT,DIM=dim) performs a circular shift on elements of ARRAY along the dimension of DIM.",
    "type": 3
  },
  "DATE_AND_TIME": {
    "args": "DATE,TIME,ZONE,VALUES",
    "doc": "DATE_AND_TIME(DATE,TIME,ZONE,VALUES) gets the corresponding date and time information from the real-time system clock.",
    "type": 2
  },
  "DBLE": {
    "args": "A",
    "doc": "DBLE(A) converts A to double precision real type.",
    "type": 3
  },
  "DIGITS": {
    "args": "X",
    "doc": "DIGITS(X) returns the number of significant binary digits of the internal model representation of X.",
    "type": 3
  },
  "DIM": {
    "args": "X,Y",
    "doc": "DIM(X,Y) returns the difference X-Y if the result is positive; otherwise returns zero.",
    "type": 3
  },
  "DOT_PRODUCT": {
    "args": "A,B",
    "doc": "DOT_PRODUCT(A,B) computes the dot product multiplication of two vectors A and B.",
    "type": 3
  },
  "DPROD": {
    "args": "X,Y",
    "doc": "DPROD(X,Y) returns the product X*Y.",
    "type": 3
  },
  "DSHIFTL": {
    "args": "I,J,SHIFT",
    "doc": "DSHIFTL(I,J,SHIFT) combines bits of I and J.",
    "type": 3
  },
  "DSHIFTR": {
    "args": "I,J,SHIFT",
    "doc": "DSHIFTR(I,J,SHIFT) combines bits of I and J.",
    "type": 3
  },
  "EOSHIFT": {
    "args": "ARRAY,SHIFT,DIM=dim",
    "doc": "EOSHIFT(ARRAY,SHIFT,BOUNDARY=boundary,DIM=dim) performs a end-off shift on elements of ARRAY along the dimension of DIM.",
    "type": 3
  },
  "EPSILON": {
    "args": "X",
    "doc": "EPSILON(X) returns the smallest number E of the same kind as X such that 1 + E > 1.",
    "type": 3
  },
  "ERF": {
    "args": "X",
    "doc": "ERF(X) computes the error function of X.",
    "type": 3
  },
  "ERFC": {
    "args": "X",
    "doc": "ERFC(X) computes the complementary error function of X.",
    "type": 3
  },
  "ERFC_SCALED": {
    "args": "X",
    "doc": "ERFC_SCALED(X) computes the exponentially-scaled complementary error function of X.",
    "type": 3
  },
  "EXECUTE_COMMAND_LINE": {
    "args": "COMMAND,WAIT=wait,EXITSTAT=exitstat,CMDSTAT=cmdstat,CMDMSG=cmdmsg",
    "doc": "EXECUTE_COMMAND_LINE(COMMAND,WAIT=wait,EXITSTAT=exitstat,CMDSTAT=cmdstat,CMDMSG=cmdmsg) runs a shell command, synchronously or asynchronously.",
    "type": 2
  },
  "EXP": {
    "args": "X",
    "doc": "EXP(X) computes the base e exponential of X.",
    "type": 3
  },
  "EXPONENT": {
    "args": "X",
    "doc": "EXPONENT(X) returns the value of the exponent part of X.",
    "type": 3
  },
  "EXTENDS_TYPE_OF": {
    "args": "A,MOLD",
    "doc": "EXTENDS_TYPE_OF(A,MOLD) queries dynamic type for extension.",
    "type": 3
  },
  "FLOOR": {
    "args": "A,KIND=kind",
    "doc": "FLOOR(A,KIND=kind) returns the greatest integer less than or equal to A.",
    "type": 3
  },
  "FRACTION": {
    "args": "X",
    "doc": "FRACTION(X) returns the fractional part of the model representation of X.",
    "type": 3
  },
  "GAMMA": {
    "args": "X",
    "doc": "GAMMA(X) computes the gamma function of X.",
    "type": 3
  },
  "GET_COMMAND": {
    "args": "COMMAND=command,LENGTH=length,STATUS=status",
    "doc": "GET_COMMAND(COMMAND=command,LENGTH=length,STATUS=status) retrieve the entire command line that was used to invoke the program.",
    "type": 2
  },
  "GET_COMMAND_ARGUMENT": {
    "args": "NUMBER=number,VALUE=value,LENGTH=length,STATUS=status",
    "doc": "GET_COMMAND_ARGUMENT(NUMBER=number,VALUE=value,LENGTH=length,STATUS=status) retrieve the NUMBER-th argument that was passed on the command line when the containing program was invoked.",
    "type": 2
  },
  "GET_ENVIRONMENT_VARIABLE": {
    "args": "NAME=name,VALUE=value,LENGTH=length,STATUS=status,TRIM_NAME=trim_name",
    "doc": "GET_ENVIRONMENT_VARIABLE(NAME=name,VALUE=value,LENGTH=length,STATUS=status,TRIM_NAME=trim_name) gets the VALUE of the environmental variable NAME.",
    "type": 2
  },
  "HUGE": {
    "args": "X",
    "doc": "HUGE(X) returns the largest number that is not an infinity in the model of the type of X.",
    "type": 3
  },
  "HYPOT": {
    "args": "X,Y",
    "doc": "HYPOT(X,Y)  is the Euclidean distance function without undue underflow or overflow.",
    "type": 3
  },
  "IACHAR": {
    "args": "I,KIND=kind",
    "doc": "IACHAR(C,KIND=kind) returns the code for the ASCII character in the first character position of C.",
    "type": 3
  },
  "IALL": {
    "args": "MASK,DIM=dim",
    "doc": "IALL(MASK,DIM=dim) reduces with bitwise AND the elements of ARRAY along dimension DIM.",
    "type": 3
  },
  "IAND": {
    "args": "I,J",
    "doc": "IAND(I,J) Bitwise logical AND.",
    "type": 3
  },
  "IANY": {
    "args": "MASK,DIM=dim",
    "doc": "IANY(MASK,DIM=dim) reduces with bitwise OR the elements of ARRAY along dimension DIM.",
    "type": 3
  },
  "IBCLR": {
    "args": "I,POS",
    "doc": "IBCLR(I,POS) returns the value of I with the bit at position POS set to zero.",
    "type": 3
  },
  "IBITS": {
    "args": "I,POS,LEN",
    "doc": "IBITS(I,POS,LEN) extracts a field of length LEN from I, starting from bit position POS and extending left for LEN bits.",
    "type": 3
  },
  "IBSET": {
    "args": "I,POS",
    "doc": "IBSET(I,POS) returns the value of I with the bit at position POS set to one.",
    "type": 3
  },
  "ICHAR": {
    "args": "I,KIND=kind",
    "doc": "ICHAR(C,KIND=kind) returns the code for the character in the first character position of C in the system's native character set.",
    "type": 3
  },
  "IEOR": {
    "args": "I,J",
    "doc": "IEOR(I,J) Bitwise logical exclusive OR.",
    "type": 3
  },
  "IMAGE_INDEX": {
    "args": "COARRAY,SUB",
    "doc": "IMAGE_INDEX(COARRAY,SUB) returns the image index belonging to a cosubscript.",
    "type": 3
  },
  "INDEX": {
    "args": "STRING,SUBSTRING,BACK=back,KIND=kind",
    "doc": "INDEX(STRING,SUBSTRING,BACK=back,KIND=kind) returns the position of the start of the first occurrence of string SUBSTRING as a substring in STRING, counting from one.",
    "type": 3
  },
  "IOR": {
    "args": "I,J",
    "doc": "IOR(I,J) Bitwise logical inclusive OR.",
    "type": 3
  },
  "IPARITY": {
    "args": "ARRAY,DIM=dim,MASK=mask",
    "doc": "IPARITY(ARRAY,DIM=dim,MASK=mask) reduces with bitwise XOR (exclusive or) the elements of ARRAY along dimension DIM if the corresponding element in MASK is TRUE.",
    "type": 3
  },
  "ISHIFT": {
    "args": "I,SHIFT",
    "doc": "ISHIFT(I,SHIFT) returns a value corresponding to I with all of the bits shifted SHIFT places",
    "type": 3
  },
  "ISHIFTC": {
    "args": "I,SHIFT,SIZE=size",
    "doc": "ISHIFTC(I,SHIFT,SIZE=size) returns a value corresponding to I with the rightmost SIZE bits shifted circularly SHIFT places; that is, bits shifted out one end are shifted into the opposite end.",
    "type": 3
  },
  "IS_IOSTAT_END": {
    "args": "I",
    "doc": "IS_IOSTAT_END(I) tests whether the variable I has the value of the I/O status 'end of file'",
    "type": 3
  },
  "IS_IOSTAT_EOR": {
    "args": "I",
    "doc": "IS_IOSTAT_EOR(I) tests whether the variable I has the value of the I/O status 'end of record'",
    "type": 3
  },
  "KIND": {
    "args": "X",
    "doc": "KIND(X) returns the kind value of the entity X.",
    "type": 3
  },
  "LBOUND": {
    "args": "ARRAY,DIM=dim,KIND=kind",
    "doc": "LBOUND(ARRAY,DIM=dim,KIND=kind) returns the lower bounds of an array, or a single lower bound along the DIM dimension.",
    "type": 3
  },
  "LEN": {
    "args": "STRING,KIND=kind",
    "doc": "LEN(STRING,KIND=kind) returns the length of a character string.",
    "type": 3
  },
  "LEN_TRIM": {
    "args": "STRING,KIND=kind",
    "doc": "LEN_TRIM(STRING,KIND=kind) returns the length of a character string, ignoring any trailing blanks.",
    "type": 3
  },
  "LGE": {
    "args": "STRING_A,STRING_B",
    "doc": "LGE(STRING_A,STRING_B) determines whether one string is lexically greater than or equal to another string.",
    "type": 3
  },
  "LGT": {
    "args": "STRING_A,STRING_B",
    "doc": "LGT(STRING_A,STRING_B) determines whether one string is lexically greater than another string.",
    "type": 3
  },
  "LLE": {
    "args": "STRING_A,STRING_B",
    "doc": "LLE(STRING_A,STRING_B) determines whether one string is lexically less than or equal to another string.",
    "type": 3
  },
  "LLT": {
    "args": "STRING_A,STRING_B",
    "doc": "LLT(STRING_A,STRING_B) determines whether one string is lexically less than another string.",
    "type": 3
  },
  "LOG": {
    "args": "X",
    "doc": "LOG(X) computes the natural logarithm of X, i.e. the logarithm to the base e.",
    "type": 3
  },
  "LOG10": {
    "args": "X",
    "doc": "LOG10(X) computes the base 10 logarithm of X.",
    "type": 3
  },
  "MATMUL": {
    "args": "MATRIX_A,MATRIX_B",
    "doc": "MATMUL(MATRIX_A,MATRIX_B) performs a matrix multiplication on numeric or logical arguments.",
    "type": 3
  },
  "MAX": {
    "args": "A1,A2",
    "doc": "MAX(A1,A2,...) returns the argument with the largest (most positive) value.",
    "type": 3
  },
  "MAXEXPONENT": {
    "args": "X",
    "doc": "MAXEXPONENT(X) returns the maximum exponent in the model of the type of X.",
    "type": 3
  },
  "MAXLOC": {
    "args": "ARRAY,DIM=dim,MASK=mask,KIND=kind,BACK=back",
    "doc": "MAXLOC(ARRAY,DIM=dim,MASK=mask,KIND=kind,BACK=back) determines the location of the element in the array with the maximum value.",
    "type": 3
  },
  "MAXVAL": {
    "args": "ARRAY,DIM=dim,MASK=mask,KIND=kind,BACK=back",
    "doc": "MAXVAL(ARRAY,DIM=dim,MASK=mask) determines the maximum value of the elements in an array.",
    "type": 3
  },
  "MERGE": {
    "args": "TSOURCE,FSOURCE,MASK",
    "doc": "MERGE(TSOURCE,FSOURCE,MASK) select values from two arrays according to a logical mask.",
    "type": 3
  },
  "MIN": {
    "args": "A1,A2",
    "doc": "MIN(A1,A2,...) returns the argument with the smallest (most negative) value.",
    "type": 3
  },
  "MINEXPONENT": {
    "args": "X",
    "doc": "MINEXPONENT(X) returns the minimum exponent in the model of the type of X.",
    "type": 3
  },
  "MINLOC": {
    "args": "ARRAY,DIM=dim,MASK=mask,KIND=kind,BACK=back",
    "doc": "MINLOC(ARRAY,DIM=dim,MASK=mask,KIND=kind,BACK=back) determines the location of the element in the array with the minimum value.",
    "type": 3
  },
  "MINVAL": {
    "args": "ARRAY,DIM=dim,MASK=mask,KIND=kind,BACK=back",
    "doc": "MINVAL(ARRAY,DIM=dim,MASK=mask) determines the minimum value of the elements in an array.",
    "type": 3
  },
  "MOD": {
    "args": "A,P",
    "doc": "MOD(A,P) computes the remainder of the division of A by P.",
    "type": 3
  },
  "MODULO": {
    "args": "A,P",
    "doc": "MODULO(A,P) computes the A modulo P.",
    "type": 3
  },
  "MOVE_ALLOC": {
    "args": "FROM,TO",
    "doc": "MOVE_ALLOC(FROM,TO) moves the allocation from FROM to TO.",
    "type": 3
  },
  "MVBITS": {
    "args": "FROM,TO",
    "doc": "MVBITS(FROM,FROMPOS,LEN,TO,TOPOS) moves LEN bits from positions FROMPOS through FROMPOS+LEN-1 of FROM to positions TOPOS through TOPOS+LEN-1 of TO.",
    "type": 3
  },
  "NEAREST": {
    "args": "X,S",
    "doc": "NEAREST(X,S) returns the processor-representable number nearest to X in the direction indicated by the sign of S.",
    "type": 3
  },
  "NEW_LINE": {
    "args": "C",
    "doc": "NEW_LINE(C) returns the new-line character.",
    "type": 3
  },
  "NINT": {
    "args": "A,KIND=kind",
    "doc": "NINT(A,KIND=kind) rounds its argument to the nearest whole number.",
    "type": 3
  },
  "NOT": {
    "args": "I",
    "doc": "NOT(I) returns the bitwise Boolean inverse of I.",
    "type": 3
  },
  "NULL": {
    "doc": "NULL() returns a disassociated pointer.",
    "type": 3
  },
  "PACK": {
    "args": "A,KIND=kind",
    "doc": "PACK(ARRAY,MASK,VECTOR=vector) stores the elements of ARRAY in an array of rank one.",
    "type": 3
  },
  "PRECISION": {
    "args": "X",
    "doc": "PRECISION(X) returns the decimal precision in the model of the type of X.",
    "type": 3
  },
  "PRESENT": {
    "args": "A",
    "doc": "PRESENT(A) determines whether an optional dummy argument is present.",
    "type": 3
  },
  "PRODUCT": {
    "args": "ARRAY,DIM=dim,MASK=mask",
    "doc": "PRODUCT(ARRAY,DIM=dim,MASK=mask) multiplies the elements of ARRAY along dimension DIM if the corresponding element in MASK is TRUE.",
    "type": 3
  },
  "RADIX": {
    "args": "X",
    "doc": "RADIX(X) returns the base of the model representing the entity X.",
    "type": 3
  },
  "RANDOM_NUMBER": {
    "args": "HARVEST",
    "doc": "RANDOM_NUMBER(HARVEST) returns a single pseudorandom number or an array of pseudorandom numbers.",
    "type": 2
  },
  "RANDOM_SEED": {
    "args": "SIZE=size,PUT=put,GET=get",
    "doc": "RANDOM_SEED(SIZE=size,PUT=put,GET=get) restarts or queries the state of the pseudorandom number generator used by RANDOM_NUMBER.",
    "type": 2
  },
  "RANGE": {
    "args": "X",
    "doc": "RANGE(X) returns the decimal exponent range in the model of the type of X.",
    "type": 3
  },
  "REPEAT": {
    "args": "STRING,NCOPIES",
    "doc": "REPEAT(STRING,NCOPIES) concatenates NCOPIES copies of a string.",
    "type": 3
  },
  "RESHAPE": {
    "args": "SOURCE,SHAPE,PAD=pad,ORDER=order",
    "doc": "RESHAPE(SOURCE,SHAPE,PAD=pad,ORDER=order) reshapes SOURCE to correspond to SHAPE.",
    "type": 3
  },
  "RRSPACING": {
    "args": "X",
    "doc": "RRSPACING(X) returns the reciprocal of the relative spacing of model numbers near X.",
    "type": 3
  },
  "SAME_TYPE_AS": {
    "args": "A,B",
    "doc": "SAME_TYPE_AS(A,B) query dynamic types for equality.",
    "type": 3
  },
  "SCALE": {
    "args": "X,I",
    "doc": "SCALE(X,I) returns X * RADIX(X)**I.",
    "type": 3
  },
  "SCAN": {
    "args": "SOURCE,KIND=kind",
    "doc": "SCAN(STRING,SET,BACK=back,KIND=kind) scans a STRING for any of the characters in a SET of characters.",
    "type": 3
  },
  "SELECTED_CHAR_KIND": {
    "args": "NAME",
    "doc": "SELECTED_CHAR_KIND(NAME) returns the kind value for the character set named NAME, if a character set with such a name is supported, or -1 otherwise.",
    "type": 3
  },
  "SELECTED_INT_KIND": {
    "args": "R",
    "doc": "SELECTED_INT_KIND(R) return the kind value of the smallest integer type that can represent all values ranging from -10^R (exclusive) to 10^R (exclusive).",
    "type": 3
  },
  "SELECTED_REAL_KIND": {
    "args": "P,R",
    "doc": "SELECTED_REAL_KIND(P,R) returns the kind value of a real data type with decimal precision of at least P digits, exponent range of at least R, and with a radix of RADIX.",
    "type": 3
  },
  "SET_EXPONENT": {
    "args": "X,I",
    "doc": "SET_EXPONENT(X,I) returns the real number whose fractional part is that that of X and whose exponent part is I.",
    "type": 3
  },
  "SHAPE": {
    "args": "SOURCE,KIND=kind",
    "doc": "SHAPE(SOURCE,KIND=kind) determines the shape of an array.",
    "type": 3
  },
  "SIGN": {
    "args": "A,B",
    "doc": "SIGN(A,B) returns the value of A with the sign of B.",
    "type": 3
  },
  "SIN": {
    "args": "X",
    "doc": "SIN(X) computes the sine of X.",
    "type": 3
  },
  "SINH": {
    "args": "X",
    "doc": "SINH(X) computes the hyperbolic sine of X.",
    "type": 3
  },
  "SIZE": {
    "args": "ARRAY,DIM=dim,KIND=kind",
    "doc": "SIZE(ARRAY,DIM=dim,KIND=kind) determines the extent of ARRAY along a specified dimension DIM, or the total number of elements in ARRAY if DIM is absent.",
    "type": 3
  },
  "SPACING": {
    "args": "X",
    "doc": "SPACING(X) determines the distance between the argument X and the nearest adjacent number of the same type.",
    "type": 3
  },
  "SPREAD": {
    "args": "SOURCE,DIM,NCOPIES",
    "doc": "SPREAD(SOURCE,DIM,NCOPIES) replicates a SOURCE array NCOPIES times along a specified dimension DIM.",
    "type": 3
  },
  "SQRT": {
    "args": "X",
    "doc": "SQRT(X) computes the square root of X.",
    "type": 3
  },
  "SUM": {
    "args": "ARRAY,DIM=dim,MASK=mask",
    "doc": "SUM(ARRAY,DIM=dim,MASK=mask) adds the elements of ARRAY along dimension DIM if the corresponding element in MASK is TRUE.",
    "type": 3
  },
  "SYSTEM_CLOCK": {
    "args": "COUNT=count,COUNT_RATE=count_rate,COUNT_MAX=count_max",
    "doc": "SYSTEM_CLOCK(COUNT=count,COUNT_RATE=count_rate,COUNT_MAX=count_max) determines the COUNT of a processor clock since an unspecified time in the past modulo COUNT_MAX, COUNT_RATE determines the number of clock ticks per second.",
    "type": 3
  },
  "TAN": {
    "args": "X",
    "doc": "TAN(X) computes the tangent of X.",
    "type": 3
  },
  "TANH": {
    "args": "X",
    "doc": "TANH(X) computes the hyperbolic tangent of X.",
    "type": 3
  },
  "TINY": {
    "args": "X",
    "doc": "TINY(X) returns the smallest positive (non zero) number in the model of the type of X.",
    "type": 3
  },
  "TRANSFER": {
    "args": "SOURCE,MOLD,SIZE=size",
    "doc": "TRANSFER(SOURCE,MOLD,SIZE=size) interprets the bitwise representation of SOURCE in memory as if it is the representation of a variable or array of the same type and type parameters as MOLD.",
    "type": 3
  },
  "TRANSPOSE": {
    "args": "MATRIX",
    "doc": "TRANSPOSE(MATRIX) transpose an array of rank two.",
    "type": 3
  },
  "TRIM": {
    "args": "STRING",
    "doc": "TRIM(STRING) removes trailing blank characters of a string.",
    "type": 3
  },
  "UBOUND": {
    "args": "ARRAY,DIM=dim,KIND=kind",
    "doc": "UBOUND(ARRAY,DIM=dim,KIND=kind) returns the upper bounds of an array, or a single upper bound along the DIM dimension.",
    "type": 3
  },
  "UPACK": {
    "args": "VECTOR,MASK,FIELD",
    "doc": "UPACK(VECTOR,MASK,FIELD) stores the elements of VECTOR in an array of higher rank.",
    "type": 3
  },
  "VERIFY": {
    "args": "STRING,SET,BACK=back,KIND=kind",
    "doc": "VERIFY(STRING,SET,BACK=back,KIND=kind) verifies that all the characters in STRING belong to the set of characters in SET.",
    "type": 3
  }
}
